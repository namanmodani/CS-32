//
// CS 32 Homework 4
// Naman Modani
// hw.txt
//

Problem 2

    The insert function calls and returns the doInsertOrUpdate and the findFirstAtLast functions,
    which use the "<" and "==" operators to compare the key that was input to the function. Since
    the key is of type Coord and the Coord class doesn't define those two operators, the compiler
    has no idea how to compare two Coord keys. This forces a compilation error.

Problem 5

    5A

        The time complexity is O(N^3) because the three nested for loops with iterating variables
        i, j, and k all run N times. The operations performed in the innermost loop is an if
        statement comparing two boolean variables, making it an O(1) operation. This results in
        the total time complexity being O(N) * O(N) * O(N) * O(1) = O(N^3)

    5B

        The innermost loop still has a complexity of O(N^3), since the loop runs an if comparison
        of two booleans - an O(1) operation - N times. For the outermost and middle for loops,
        they would be running the innermost loop a total of 0 + 1 + ... + (N - 1) times, which
        has a time complexity of O(N^2). Although j goes from 0 to (i - 1) and not 0 to (N - 1),
        the maximum possible iteration count of the loop with j is N. The algorithm would be
        running an O(N) operation O(N^2) times, making the total time complexity O(N) * O(N^2) =
        O(N^3).

Problem 6

    6A

        In terms of the number of linked list nodes visited during the execution of this function
        alone, the time complexity would be O(N) since each node in "m" gets copied to "res," and
        there are N node in "m." Taking into account the fact that the get() function has a O(N)
        complexity, the function is bounded by a maximum of N/2 nodes visited. This is proportional
        to N make the function O(N). Therefore - since an O(N) function is performed O(N) times,
        and all other functions have a O(1) complexity - the total time complexity of the reassign
        function would be O(N^2).

    6B

        The function has a time complexity of O(N), because N nodes are visited and each has an
        O(1) operation performed - the O(1) operation being the reassignment of the node's
        member variable. This implementation is better than the one in 6A, since upon incrementing
        the number of nodes, the 6A algorithm increases runtime exponentially, while this algorithm
        increases runtime linearly. This means that no matter how much higher the baseline overhead
        of this function is than 6A - eventually, as N increases, this algorithm will perform faster.





